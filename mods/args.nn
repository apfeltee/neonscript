/*
#
# @module args
#
# This module provides functionalities that makes writing command-line 
# interfaces easy. A user can define the options and commands available 
# in a program and this module can automatically figure out how to parse 
# those options and commands out of the CLI arguments. It also provides 
# automatic help and usage messages as well as error/warnings generation 
# for valid/invalid arguments.
# 
# ### Example
# 
# The below is a simple program that shows a typical use of the module.
# 
# ```blade
# import args
# 
# var parser = args.Parser('myprogram')
# parser.add_option('name', 'The name of person to call', {type: args.STRING})
# parser.add_command('call', 'Make a phone call')
# parser.parse()
# ```
# 
# We can simply print help information for the above program if it were saved 
# in a file `myprogram.b` as follows.
# 
# ```sh
# $ blade myprogram.b -h 
# Usage: myprogram [ [-h] | [--name NAME] ] [COMMAND]
# 
# OPTIONS:
#   -h, --help                 Show this help message and exit
#       --name <value>         The name of person to call
# 
# COMMANDS:
#   call                       Make a phone call
# ```
# 
# if we change the last line of the program to `echo parser.parse()` so that we 
# can see the result of the parsing, the following CLI call will yield the given result.
# 
# ```terminal
# $ blade myprogram.b --name 25
# {options: {name: 25}, command: null}
# 
# $ blade myprogram.b call  
# {options: {}, command: {name: call, value: null}}
# 
# $ blade myprogram.b call --name 25
# {options: {name: 25}, command: {name: call, value: null}}
# ```
# 
# Calling name without an option will yield the following result/error.
# 
# ```sh
# $ blade myprogram.b --name   
# error: Option "name" expects a value
# ```
# 
# You may even get help on a command directly like below:
# 
# ```sh
# $ blade myprogram.b --help call
# Usage: myprogram call
# 
#   Make a phone call
# ```
# 
# @copyright 2021, Ore Richard Muyiwa and Blade contributors
#
*/

var colors = import "colors"


/**
 * value type none
 */
var NONE = 0

/**
 * value type integer (allows numbers, but floors them to integers)
 */
var INT = 1

/**
 * value type number
 */
var NUMBER = 2

/**
 * value type boolean (accepts `1` and `0` as well as `true` 
 * and `false` as valid values).
 */
var BOOL = 3

/**
 * value type string
 */
var STRING = 4

/**
 * value type for list
 */
var LIST = 5

/**
 * value type enumeration choices.
 */
var CHOICE = 6

/**
* value type optional.
*/
var OPTIONAL = 7

var _type_name = {
  0: '',
  1: 'integer',
  2: 'number',
  3: 'boolean',
  4: 'value',
  5: 'list',
  6: 'choice',
  7: 'value',
}

function _muted_text(text) {
  return colors.text(text, colors.text_color.dark_grey)
}

function _bold_text(text) {
  return colors.text(colors.text(text), colors.style.bold)
}

function _main_headings(text) {
  return colors.text(colors.text(text, colors.text_color.green), colors.style.bold)
}

function _cyan_text(text) {
  return colors.text(colors.text(text, colors.text_color.cyan), colors.style.bold)
}

function _get_real_value(item, value) {
  if item.type == INT return to_int(to_number(value))
  else if item.type == NUMBER return to_number(value)
  else if item.type == BOOL return value == 'true' or value == '1'
  else if item.type == STRING return to_string(value)
  else if item.type == LIST return [value]
  else if item.type == CHOICE {
    return item.choices.contains(value) ? value : null
  }
  return value
}

/**
 * Commandline argument exception.
 */
class ArgsException extends Exception {
  /**
   * ArgsException(message: string)
   * @constructor
   */
  constructor(message) {
    super(message)
  }
}

class _Option {
  constructor(long_name, help, short_name, type, required, choices) {
    this.long_name = long_name
    this.help = help ? help : ''
    this.short_name = short_name
    this.type = type ? type : NONE
    this.required = required
    this.choices = choices
    this.options = null // required for _Option and subclasses

    if type < NONE or type > OPTIONAL
      throw ArgsException('invalid value type')
  }
}

class _Optionable {

  var options = []
  var choices = []
  
  add_option(name, help, opts) {
    if !is_string(name)
      throw ArgsException('name expected')
    if help != null and !is_string(help)
      throw ArgsException('help message must be string')
    if opts == null opts = {}
    else if !is_dict(opts)
      throw ArgsException('opts must be a dict')

    // Ensure we don't have duplicated option declarations.
    foreach(o in this.options) {
      if o.long_name == name or o.short_name == name
        throw ArgsException('option with name "${name}" previously declared')
    }

    var short_name = opts.get('short_name'),
        type = to_int(to_number(opts.get('type', NONE))),
        required = opts.get('required', false),
        choices = opts.get('choices', [])

    if short_name != null and !is_string(short_name)
      throw ArgsException('short_name must be string')
    if required != null and !is_bool(required)
      throw ArgsException('required must be boolean')
    if !is_list(choices) and !is_dict(choices)
      throw ArgsException('choices must be a list or dictionary')

    this.options.append(_Option(name, help, short_name, type, required, choices))

    if instance_of(this, _Command)
      return this
  }
}

class _Command extends _Optionable {
  constructor(name, help, type, action, choices) {
    if !is_string(name)
      throw ArgsException('name expected')
    if help != null and !is_string(help)
      throw ArgsException('help message must be string')
    if action != null and !is_function(action)
      throw ArgsException('action must be of type function(options: dict)')
    if choices != null and !is_list(choices) and !is_dict(choices)
      throw ArgsException('choices must be of type list')

    this.name = name
    this.help = help
    this.type = type
    this.choices = choices or []
  }
}

/**
 * A configurable commandline parser.
 */
class Parser extends _Optionable {
  /**
   * A list of commands supported by the parser.
   */
  var commands = []
  var _default_help = true

  /**
   * Parser(name: string [, default_help: bool = true])
   * @param `name` refers to the name of the cli program.
   * @param `default_help` whether to show help when no command or option is matched or not.
   * @constructor
   */
  constructor(name, default_help) {
    if !is_string(name)
      throw Exception('missing program name')
    if default_help != null and !is_bool(default_help)
      throw Exception('bool expected in argument 2 (default_help)')
    if default_help == null default_help = true

    this._default_help = default_help

    this.name = name
    this._command = null

    // Initalize the automatic help option.
    this.add_option(
      'help', 
      'Show this help message and exit', 
      {
        short_name: 'h',
        required: false,
      }
    )
  }

  _get_option(source, name) {
    var result = []
    foreach(opt in source) {
      if '--${opt.long_name}' == name {
        result.append(opt)
      } else if name.starts_with('-') and name.length() > 1 {
        if name[1] != '-' {  // we are not matching -- here...
          foreach( n in name) {
            if opt.short_name == n
              result.append(opt)
          }
        }
      }
    }
    return result
  }

  _get_command(name) {
    foreach(command in this.commands) {
      if command.name == name
        return command
    }
    return null
  }

  _get_help(opt) {
    var response = opt.help or _muted_text('<no help message>')
    if opt.options {
      var options_width = this._get_options_text_width(),
        commands_width = this._get_commands_text_width(),
        width = options_width > commands_width ? options_width : commands_width
      
      foreach( op in opt.options) {

        var line = '\n'
        if op.short_name {
          line += '-${op.short_name},'.lpad(op.short_name.length() + 6) + ' --${op.long_name}'
        } else {
          line += '--${op.long_name}'.lpad(op.long_name.length() + 6)
        }

        line += this._opt_line(op)

        // We want to separate the longtest option names at least 12
        // characters away from the help texts.
        line = line.rpad(width + 8)



        if opt.type == CHOICE {
          response += '\n' + this._get_choice_help(opt.choices)
        }

        response += _muted_text(line + this._get_help(op))
      }
    }
    return response
  }

  _get_choice_help(opt) {
    var options_width = this._get_options_text_width(),
      commands_width = this._get_commands_text_width(),
      width = options_width > commands_width ? options_width : commands_width

    if is_dict(opt) {
      var response = !opt ? _muted_text('<no help message>') : ''
      foreach( k, v in opt) {
        var line = '${k}'.lpad(k.length() + 4)

        // We want to separate the longtest option names at least 12
        // characters away from the help texts.
        line = colors.text(line, colors.style.italic).rpad(width + 17)

        response += line + v + '\n'
      }

      return response.rtrim('\n')
    } else {
      return _muted_text(('[' + ', '.join(opt) + ']').lpad(this._get_commands_text_width() + 6))
    }
  }

  _get_hint_line(opt) {
    var line

    if opt.short_name line += '-${opt.short_name}'
    else line += '--${opt.long_name}'

    if opt.type != NONE
      line += ' ${opt.long_name.upper()}'
    return line
  }

  _get_flags_hint() {
    var list = []
    foreach(opt in this.options) {
      list.append('[${this._get_hint_line(opt)}]')
    }
    return ' | '.join(list)
  }

  _get_options_text_width() {
    var width = 0
    foreach(opt in this.options) {
      var n
      if opt.short_name {
        n = opt.short_name.length() + opt.long_name.length() + 2 // +2 for ', '
      } else {
        n = opt.long_name.length() + 4 // 4 should cover all short names.
      }

      if opt.type != NONE
        n += opt.long_name.length() + _type_name[opt.type].length()

      if n > width width = n
    }
    return width
  }

  _get_commands_text_width() {
    var width = 0
    foreach(opt in this.commands) {
      var n = opt.name.length()

      if opt.type != NONE
        n += opt.name.length() + _type_name[opt.type].length()

      if n > width width = n
    }
    return width
  }

  _usage_hint(command) {
    if !command {
      var flags_hint = this._get_flags_hint()

      echo _main_headings('Usage:') + _cyan_text(' ${this.name} ' + 
        (flags_hint ? '[ ${flags_hint} ]' : '') + 
        (this.commands.length() > 0 ? ' [COMMAND]' : ""))
    } else {
      echo _main_headings('Usage:') + _cyan_text(' ${this.name} ${command.name}' + 
          (command.type != NONE ? ' <${_type_name[command.type]}>' : ""))
    }
  }

  _command_error(name, message) {
    print(colors.text('error: ${message}\n', colors.text_color.red))
    this._help_action(name)
    exit(1)
  }

  _option_error(name, message) {
    print(colors.text('error: ${message}\n', colors.text_color.red))
    this._print_help()
    exit(1)
  }

  _opt_line(opt) {
    if opt.type != NONE {
      return " <" + _type_name[opt.type] + '>'
    }
    return ''
  }

  _print_help() {
    var options_width = this._get_options_text_width(),
        commands_width = this._get_commands_text_width(),
        width = options_width > commands_width ? options_width : commands_width
    
    echo ''
    echo _main_headings('OPTIONS:')
    foreach(opt in this.options) {
      var line = ''
      if opt.short_name {
        line += '-${opt.short_name},'.lpad(opt.short_name.length() + 4) + ' --${opt.long_name}'
      } else {
        line += '--${opt.long_name}'.lpad(opt.long_name.length() + 8)
      }

      line += this._opt_line(opt)

      // We want to separate the longtest option names at least 12
      // characters away from the help texts.
      line = line.rpad(width + 5)

      echo line + this._get_help(opt)
    }
    echo ''
    echo _main_headings('COMMANDS:')
    foreach(opt in this.commands) {
      var line = '  ' + _bold_text(opt.name)

      line += this._opt_line(opt)

      // We want to separate the longtest option names at least 12
      // characters away from the help texts.
      line = line.rpad(width + 20)

      echo line + this._get_help(opt)
    }
  }

  // This method should ever be called directly.
  _help_action(command) {
    command = command or this._command
    var original_command = command

    if !command {
      this._usage_hint(command)
      this._print_help()
    } else {
      command = this._get_command(command)
      if command {
        this._usage_hint(command)
        echo '  ${this._get_help(command)}'
      } else {
        this._usage_hint(command)
        this._print_help()
      }
    }
  }

  /**
   * add_option(name: string [, help: string [, opts: dict]])
   * 
   * adds a support for a new command to the parser.
   * 
   * The `opts` dictionary can contain one or more of:
   * 
   * - `short_name`: A shorter version of the option name parsed via 
   * single hyphens (`-`) without the hyphen. For example, short_name `v` 
   * will match `-v` in the commandline.
   * - `type`: type must be one of the args types and will indicate 
   * how the parsed data should be interpreted in the final result.
   * - `required`: tells the parser if a value is compulsory for this option.
   * - `choices`: a list of allowed options or a dictionary of allowed 
   * options with their respective descriptions.
   * 
   * @note the `choices` option only works for type `CHOICE`.
   */
  add_option(name, help, opts) {
    super.add_option(name, help, opts)
  }

  /**
   * add_command(name: string [, help: string [, opts: dict]])
   * 
   * adds a support for a new command to the parser.
   * 
   * The `opts` dictionary can contain property `type` and `action`.
   * 
   * - The `type` property a must be one of the args types and will indicate 
   * how the parsed data should be interpreted in the final result.
   * - The `action` property must be a function.
   * 
   * The `opts` dictionary can contain one or more of:
   * 
   * - `type`: type must be one of the args types and will indicate 
   * how the parsed data should be interpreted in the final result.
   * - `required`: tells the parser if a value is compulsory for this option.
   * - `choices`: a list of allowed options or a dictionary of allowed 
   * options with their respective descriptions.
   * 
   * @note the `choices` option only works for type `CHOICE`.
   */
  add_command(name, help, opts) {
    if !is_string(name)
      throw ArgsException('name expected')
    if help != null and !is_string(help)
      throw ArgsException('help message must be string')
    if opts == null opts = {}
    else if !is_dict(opts)
      throw ArgsException('opts must be a dict')

    // Ensure we don't have duplicated option declarations.
    foreach(o in this.commands) {
      if o.name == name
        throw ArgsException('option with name "${name}" previously declared')
    }

    var type = to_int(to_number(opts.get('type', NONE))),
        action = opts.get('action'),
        choices = opts.get('choices', [])

    var command = _Command(name, help, type, action, choices)
    this.commands.append(command)
    return command
  }

  /**
   * parse()
   * 
   * Parses the commandline arguments and returns a dictionary of command 
   * and options.
   * 
   * For example, parsing the commandline
   * `blade test.b install 5 --verbose` may yeild such a result as 
   * `{options: {verbose: true}, command: {name: install, value: 5}}`.
   * 
   * @return dict
   */
  parse() {
    // We have to strip out the application name and the script path.
    var cli_args = ARGV[2,]
    var parsed_args = {
      options: {},
      command: null,
    }
    var help_shown = false

    for(var i = 0; i < cli_args.length(); i++) {
      var arg = cli_args[i]
      var command_found = false

      // Commands can only occur in the first index of the argument list. 
      // Every other occurrence will be treated as a value.
      // if i == 0 {
      // Then treat commands.
      var command = this._get_command(arg)

      function parse_options(source, arg, fail) {
        var options = this._get_option(source, arg)
        if options and (options.length() == arg.length() - 1 or arg.starts_with('--')) {
          i++

          // ...
          foreach(option in options) {
            // We only automatically trigger actions for options during parsing 
            // if the option is the very first item in the argument list and == 'help'.
            // This is because this action is library bound and are meant to be triggered
            // automatically.
            if option.long_name == 'help' and !command_found {
              help_shown = true
              this._help_action(i < cli_args.length() - 1 ? cli_args[i + 1] : null)
            } else if option.type == OPTIONAL {
              if i < cli_args.length() {
                i++
                if i < cli_args.length() {
                  var value = cli_args[i]
                  parsed_args.options.set(
                    '${option.long_name}', 
                    _get_real_value(option, value)
                  )
                  continue
                }
                
                this._option_error(option.long_name, 'Option "${option.long_name}" expects a ${_type_name[option.type]}')
              }
            } else if option.type != NONE {
              if i < cli_args.length() {
                var value = cli_args[i]
                var v = _get_real_value(option, value)
                if v {
                  parsed_args.options.set('${option.long_name}', v)
                  continue
                }
              }

              var msg = 'Option "${option.long_name}" expects a ${_type_name[option.type]}'
              if option.type == CHOICE and option.choices 
                msg += " as one of \'${"', '".join(option.choices)}\'"
              this._option_error(option.long_name, msg)
            } else {
              parsed_args.options.set('${option.long_name}', true)
            }
          }
        } else if options and (arg.length() - 1 != options.length() or !arg.starts_with('--')) {
          if command_found {
            this._command_error(command.name, 'Unsupported argument encountered at ${arg}')
          } else {
            this._option_error(arg, 'Unsupported argument: ${arg}')
          }
        } else if fail or arg.starts_with('-') {
          if command_found {
            this._command_error(command.name, 'Unknown argument ${arg} for ${command.name}')
          } else {
            this._option_error(arg, 'Unknown argument: ${arg}')
          }
        }
      }

      if command {
        command_found = true
        this._command = command.name

        // If options exist, we must parse them here... before 
        // we parse value.
        while i < cli_args.length() - 1 and cli_args[i + 1].starts_with('-') {
          parse_options(command.options, cli_args[i + 1])
        }

        if command.type != NONE or command.type == OPTIONAL {
          if i < cli_args.length() - 1 {
            i++
            var value = cli_args[i]
            var v = _get_real_value(command, value)

            if v or command.type != CHOICE or !command.choices {
              parsed_args.command = {
                name: command.name,
                value: v
              }

              if command.type == LIST {
                while i < cli_args.length() - 1 {
                  i++
                  parsed_args.command.value.append(cli_args[i])
                }
              }
            } else {
              this._command_error(command.name, 'Command "${command.name}" expects a ${_type_name[command.type]} as one of \'${"', '".join(command.choices)}\'')
            }
          } else if command.type != OPTIONAL {
            this._command_error(command.name, 'Command "${command.name}" expects a ${_type_name[command.type]}')
          }
        } else {
          parsed_args.command = {
            name: command.name,
            value: null
          }
        }
      }
      // }

      if !command_found {
        // Treat options next.
        parse_options(this.options, arg, true)
      }
    }

    if !parsed_args.command and !parsed_args.options and this._default_help and !help_shown {
      this._usage_hint()
      this._print_help()
    }

    return parsed_args
  }
}

