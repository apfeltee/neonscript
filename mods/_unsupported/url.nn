/*
# @module url
#  
# This module provides classes and functions for parsing and processing URLs.
# This module supports username and passwords in URLs in order to support an 
# arbitrary number of RFC combinations but this does not strictly conform to 
# RFC1738.
# 
# The scope of URL in this module have not been limited to HTTP or any protocol 
# for that matter. However, where deducable, the module tries to conform to the 
# most appropriate URL for the specified scheme.
# 
# Constructing a URL is vey simple. Here is an example.
# 
# ### Example,
# 
# ```blade-repl
# %> import url
# %> var link = url.Url('https', 'example.com', 9000)
# %> link.absolute_url()
# 'https://example.com:9000'
# ```
# 
# What each function and class method does are easy to deduce from their names.
# 
# For example, we can use the `parse()` function to convert a URL string into a URL 
# instance like below.
# 
# ```blade-repl
# %> link = url.parse('https://example.com:9000')
# %> link.scheme
# 'https'
# %> link.port
# '9000'
# ```
# 
# @copyright 2021, Ore Richard Muyiwa and Blade contributors
# 
*/

var types = import "types";


/**
 * Excpetion thrown when a url is malformed
 */
class UrlMalformedException < Exception {
  /**
   * UrlMalformedException(message: string)
   * @constructor
   */
  UrlMalformedException(message) {
    parent(message)
  }
}


# a list of schemes that does not conform to the standard ://
# after the scheme name in their urls
var _SIMPLE_SCHEMES = ['mailto', 'tel']

var _ipv6_regex = '/(?:^|(?<=\\s))(([0-9a-fA-F]{1,4}:)' +
  '{7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]' +
  '{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]' + 
  '{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]' + 
  '{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]' +
  '{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4})' +
  '{1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:)' +
  '{0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}' +
  '[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}' +
  '[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))(?=\\s|$)/'


/**
 * The Url class provides functionalities for parsing and processing URLs
 * @serializable
 * @printable
 */
class Url {

  /**
   * The url scheme e.g. http, https, ftp, tcp etc.
   */
  var scheme

  /**
   * The host information contained in the url
   */
  var host

  /**
   * The port information contained in the url whenever the url doesn't 
   * indicate, we try to make a best guess based on the scheme.
   */
  var port

  /**
   * The path of the URL.
   * @default /
   */
  var path = '/'

  /**
   * Hash information contained in the url and it's beginning is indicated by the 
   * hash (#) sign. This value is especially relevant to some http/https urls 
   * and are usually references to the content of the document 
   * at the given url
   */
  var hash

  /**
   * Query/Search information contained in the url and it's beginning is indicated by the 
   * question (?) sign. This value is especially relevant to some http/https urls and are 
   * usually used to convey data to endpoint based on the GET method.
   */
  var query

  /**
   * Username information for authentication are sometimes embeded in urls. When such information 
   * exist, this property holds the information
   */
  var username

  /**
   * Password information for authentication are sometimes embeded in urls. When such information 
   * exist, this property holds the information
   */
  var password

  /**
   * Url(scheme: string, host: string [, port: string [, path: string [, query: string [, hash: string [, username: string [, password: string]]]]]])
   * @constructor 
   */
  Url(scheme, host, port, path, query, hash, username, password) {
    if !is_string(scheme)
      throw Exception('scheme must be string')
    if !is_string(host)
      throw Exception('host must be string')
    if port != null and !is_string(port) and !is_int(port)
      throw Exception('port must be string or integer')
    if path != null and !is_string(path)
      throw Exception('path must be string')
    if query != null and !is_string(query)
      throw Exception('query must be string')
    if hash != null and !is_string(hash)
      throw Exception('hash must be string')
    if username != null and !is_string(username)
      throw Exception('username must be string')
    if password != null and !is_string(password)
      throw Exception('password must be string')

    if is_number(port) port = to_string(port)

    this.scheme = scheme
    this.host = host
    this.port = port
    this.path = path
    this.query = query
    this.hash = hash
    this.username = username
    this.password = password
  }

  /**
   * authority()
   * returns the url authority
   * 
   * The authority component is preceded by a double slash ("//") and is
   * terminated by the next slash ("/"), question mark ("?"), or number
   * sign ("#") character, or by the end of the URI.
   *
   * @note mailto scheme does not have an authority. For this reason, mailto schemes return an empty string as authority.
   * @return string
   */
  authority() {
    if this.scheme != 'mailto' {
      var authority = ''

      # some schemes do not allow the userinfo and/or port subcomponents
      # RFC 3986 [Page 17]
      if this.username {
        authority += '${this.username}:'

        if this.password authority += this.password
        authority += '@'
      }
      authority += this.host

      # URI producers and normalizers should omit the ":" delimiter that
      # separates host from port if the port component is empty
      if this.port and this.port > 0 authority += ':${this.port}'

      return authority
    }
    return ''
  }

  /**
   * host_is_ipv4()
   * 
   * returns true if the host of the url is a valid ipv4 address
   * and false otherwise
   * @return bool
   */
  host_is_ipv4() {
    if this.host {
      return this.host.match('/^((25[0-5]|(2[0-4]|1[0-9]|[1-9]|)[0-9])(\\.(?!$)|$)){4}$/')
    }
    return false
  }

  /**
   * host_is_ipv6()
   * 
   * returns true if the host of the url is a valid ipv6 address
   * and false otherwise
   * @return bool
   */
  host_is_ipv6() {
    if this.host {
      var matched = this.host.match(_ipv6_regex)
      return matched and matched.length() > 0
    }
    return false
  }

  /**
   * absolute_url()
   * 
   * returns absolute url string of the url object
   * @return string
   */
  absolute_url() {
    var url = '${this.scheme}:'

    if !_SIMPLE_SCHEMES.contains(this.scheme) {
      url += '//'
    }

    # build the username:password symbol
    if this.username {
      url += '${this.username}:'
      if this.password {
        url += this.password
      }
      url += '@'
    }

    url += this.host

    if this.port {
      url += ':${this.port}'
    }
    if this.path {
      if this.path == '/' and _SIMPLE_SCHEMES.contains(this.scheme) {
        # do nothing...
      } else {
        url += this.path
      }
    }
    if this.hash {
      url += '#${this.hash}'
    }
    if this.query {
      url += '?${this.query}'
    }

    return url
  }

  @to_string() {
    return '<Url href=${this.absolute_url()}>'
  }

  @to_json() {
    return {
      scheme: this.scheme,
      host: this.host,
      port: this.port,
      path: this.path,
      query: this.query,
      hash: this.hash,
      username: this.username,
      password: this.password,
    }
  }
}



/**
 * encode(url: string, strict: boolean)
 * 
 * URL-encodes string
 * 
 * this function is convenient when encoding a string to be used in 
 * a query part of a URL, as a convenient way to pass variables to 
 * the next page.
 *
 * if strict mode is enabled, space character is encoded with the 
 * percent (%) sign in order to conform with RFC 3986. Otherwise,
 * is is encoded with the plus (+) sign in order to align with
 * the default encoding used by modern browsers.
 * @return string
 * @defualt strict: false
 * @note strict mode is disabled by default
 */
function encode(url, strict) {
  if !is_string(url)
    throw Exception('string expected at parameter 1')

  if strict != null and !is_bool(strict) 
    throw Exception('boolean expected at parameter 2')

  var result = ''

  foreach c in url {
    // keep alphanumeric and other accepted characters intact
    if c.is_alnum() or c == '-' or c == '_' or c == '.' or c == '~'
      result += c
    // when not in strict mode
    else if !strict and c == ' ' result += '+'
    // encode all other characters
    else result += '%${hex(ord(c))}'.upper()
  }

  return result
}

/**
 * decode(url: string)
 * 
 * Decodes URL-encoded string
 * 
 * decodes any %## encoding in the given string. 
 * plus symbols ('+') are decoded to a space character.
 * @return string
 */
function decode(url) {
  if !is_string(url)
    throw Exception('string expected')

  // quick exit strategy
  if url.index_of('%') > -1 return url

  var lookup_table = '0123456789abcdef'

  var result = ''

  iter var i = 0; i < url.length(); i++ {
    if url[i] == '%' {
      // decode percent-encoded data here
      var hexdata = url[i+1, i+3].lower()

      if hexdata.length() != 2 throw UrlMalformedException('bad encoding')

      result += chr((lookup_table.index_of(hexdata[0]) * 16) + lookup_table.index_of(hexdata[1]))
      i += 2
    } 
    // + should be converted to space as most browsers
    // will encode space to + (non-strict Url.decode mode)
    else if url[i] == '+' result += ' '
    else result += url[i]
  }

  return result
}

/**
 * parse(url: string)
 *
 * parses given url string into a Url object
 * @return Url
 */
function parse(url) {
  if !is_string(url) throw Exception('string expected')
  url = url.trim() // support urls surrounded by whitespaces

  var scheme, host, port, path = '/', query, hash, username, password

  # following that most urls written without indicating the scheme
  # are usually http urls, default url scheme to http if none was given
  # do not do this only when the scheme is mailto:
  if url.index_of('://') < 0 {
    var match_found = false
    foreach sc in _SIMPLE_SCHEMES {
      if url.starts_with(sc) {
        match_found = true
        break
      }
    }

    if !match_found {
      url = 'http://${url}'
    }
  }

  # query/search and hash entries tracker
  var query_starts = false
  var hash_starts = false

  iter var i = 0; i < url.length(); i++ {

    # simple anonymous function to scan port
    var _scan_port = || {
        var _port = ''
        i++
        while i < url.length() and types.digit(url[i]) { # id_digit
          _port += url[i]
          i++
        }
        port = to_number(_port)
    }

    if url[i] == ':' {
      if !scheme {
        # scan the scheme
        scheme = url[0, i]

        # skipping // if scheme is not mailto as mailto that does not use the //
        if scheme != 'mailto' {
          # if the // is missing, it's a malformed url
          if url[i,i+3] != '://' 
            throw UrlMalformedException('expected // at index ${i}')
          i += 2
        }

        # Scheme names consist of a sequence of characters beginning with a
        # letter and followed by any combination of letters, digits, plus
        # ("+"), period ("."), or hyphen ("-").  Although schemes are case-
        # insensitive, the canonical form is lowercase and documents that
        # specify schemes must do so with lowercase letters.  An implementation
        # should accept uppercase letters as equivalent to lowercase in scheme
        # names (e.g., allow "HTTP" as well as "http") for the sake of robustness.
        # https://tools.ietf.org/html/rfc3986#section-3.1
        if !scheme.match('/^[a-z][a-z0-9+.]+$/i')
          throw UrlMalformedException('invalid scheme')
      } else if !port {
        # scan the port number
        _scan_port()
      }
    } else if !host and scheme {
      # scan the host
      host = ''
      while i < url.length() and (types.digit(url[i]) or types.alpha(url[i]) or 
          url[i] == '.' or url[i] == '@' or url[i] == '-') {
        host += url[i]
        i++
      }

      if i < url.length() - 1 and url[i] == ':' {
        if url.length() - 1 > i and (types.alpha(url[i + 1]) or url[i + 1] == '@') {
          # username password combo encountered...
          username = host
          host = null # we'll need to rescan for the host later...

          password = ''

          if url[i + 1] != '@' {
            password = ''
            i++

            while i < url.length() and url[i] != '@' {
              password += url[i]
              i++
            }

            if url.length() == i {
              # we read the entire url without a terminating @ sign...
              # something is wrong with this url and the url is definitely
              # malformed...
              throw UrlMalformedException('url not complete')
            }

            # we need to go back to @ to let host be scanned completely
            # at the next iteration because we are now on the first
            # character of the host segement
            i--
          }
        }
        _scan_port()
      }

      # check if the host contains username data
      # e.g. mailto:username@example.com
      if host and host.index_of('@') > -1 {
        var _ = host.split('@')
        username = _[0]
        host = _[1]
      }
    } else if path == '/' and host {
      # scan the address

      # the path is terminated by the first question mark ("?") or 
      # number sign ("#") character, or by the end of the URI
      while i < url.length() and url[i] != '?' and url[i] != '#' {
        path += url[i]
        i++
      }

      # the path cannot begin with two slash characters
      # https://tools.ietf.org/html/rfc3986#section-3.3
      if path.starts_with('//') throw UrlMalformedException('invalid path')

      # what should we parse next
      query_starts = i < url.length() and url[i] == '?'
      hash_starts = i < url.length() and url[i] == '#'
    } else if query_starts {

      if hash_starts {
        # this is an edge-case where we have the url hash coming
        # before the url query segement.
        # while this may be allowed by specific implementations,
        # but RFC 3986 doesn't allow this.
        # for this library, we are going strictly RFC 3986
        # https://tools.ietf.org/html/rfc3986#section-3.4
        throw UrlMalformedException('query not allowed at index ${i}')
      }

      # scan the query
      # the query is always the last part of a url
      query = ''
      while i < url.length() and url[i] != '#' {
        query += url[i]
        i++
      }

      # reset for some abnormal urls that may be correct in users implementation
      query_starts = false

      hash_starts = i < url.length() and url[i] == '#'
    } else if hash_starts {
      # scan the hash
      hash = ''

      # we are still checking for the ? character
      # this ensures we don't eroneously 
      while i < url.length() {
        hash += url[i]
        i++
      }
    }
  }

  # build a new Url instance and return
  return Url(scheme, host, port, path, query, hash, username, password)
}
